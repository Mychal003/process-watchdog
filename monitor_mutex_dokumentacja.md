# Monitor Mutex - Dokumentacja

## Opis

`monitor_mutex.go` to zaawansowany system monitorowania proces√≥w, kt√≥ry automatycznie restartuje aplikacje w przypadku braku aktywno≈õci w plikach log√≥w. Monitor dzia≈Ça w oparciu o zasadƒô "watchdog" - obserwuje pliki log√≥w i restartuje proces je≈õli przez okre≈õlony czas nie pojawiajƒÖ siƒô nowe wpisy.

## G≈Ç√≥wne funkcje

### üîÑ Automatyczny restart proces√≥w
- **Monitorowanie plik√≥w log√≥w** - wykrywanie nowych wpis√≥w przez rozmiar i czas modyfikacji
- **Inteligentny timeout** - restart po okre≈õlonym czasie braku aktywno≈õci
- **Graceful shutdown** - grzeczne zamykanie proces√≥w (SIGTERM ‚Üí SIGKILL)

### ‚öôÔ∏è Elastyczna konfiguracja
- **Tryb pojedynczy** - monitorowanie jednego procesu z parametrami CLI
- **Tryb YAML** - zarzƒÖdzanie wieloma procesami z pliku konfiguracyjnego
- **Dostosowywalne parametry** - timeout, interwa≈Ç sprawdzania, ≈õcie≈ºki log√≥w

### üõ°Ô∏è Bezpiecze≈Ñstwo i stabilno≈õƒá
- **Thread-safe** - zabezpieczenie mutex dla operacji wielowƒÖtkowych
- **Context handling** - prawid≈Çowe zamykanie przy sygna≈Çach systemowych
- **Error recovery** - kontynuacja dzia≈Çania przy b≈Çƒôdach przej≈õciowych

## Sposoby uruchomienia

### 1. Tryb pojedynczy
```bash
./monitor_mutex "komenda" "/≈õcie≈ºka/do/log√≥w" [timeout] [interwa≈Ç]
```

### 2. Tryb wieloprocesowy (YAML)
```bash
./monitor_mutex --config konfiguracja.yaml
```

## Przyk≈Çady u≈ºycia

### Podstawowe monitorowanie
```bash
# Monitoruj aplikacjƒô Python
./monitor_mutex "python3 app.py > /tmp/app.log 2>&1" "/tmp/app.log"

# Monitoruj serwer z niestandardowym timeoutem
./monitor_mutex "java -jar server.jar" "/var/log/server.log" 120 10

# Monitoruj skrypt z przekierowaniem log√≥w
./monitor_mutex "bash backup.sh >> /var/log/backup.log" "/var/log/backup.log" 300 30
```

### Konfiguracja YAML
```yaml
# monitor_config.yaml
processes:
  - name: "WebServer"
    command: "python3 -m http.server 8080"
    log_file: "/tmp/webserver.log"
    timeout: 60
    interval: 5

  - name: "Database"
    command: "mysqld --defaults-file=/etc/mysql/my.cnf"
    log_file: "/var/log/mysql/error.log"
    timeout: 120
    interval: 10

  - name: "Worker"
    command: "python3 worker.py >> /tmp/worker.log 2>&1"
    log_file: "/tmp/worker.log"
    timeout: 180
    interval: 15
```

### Uruchomienie z konfiguracjƒÖ
```bash
# Kompilacja
go build monitor_mutex.go

# Uruchomienie
./monitor_mutex --config monitor_config.yaml
```

## Parametry konfiguracji

### Parametry g≈Ç√≥wne

| Parametr | Opis | Domy≈õlna warto≈õƒá | Zakres |
|----------|------|------------------|---------|
| `name` | Nazwa procesu (tylko YAML) | - | string |
| `command` | Komenda do uruchomienia | - | string |
| `log_file` | ≈öcie≈ºka do pliku log√≥w | - | string |
| `timeout` | Timeout w sekundach | 60 | 1-3600 |
| `interval` | Interwa≈Ç sprawdzania w sekundach | 5 | 1-300 |

### Szczeg√≥≈Çowy opis parametr√≥w

#### `command`
Pe≈Çna komenda do uruchomienia procesu. Mo≈ºe zawieraƒá:
- Argumenty linii komend
- Przekierowania wyj≈õcia (`>`, `>>`, `2>&1`)
- Pipe'y i ≈ÇƒÖczenie komend (`|`, `&&`)

```bash
# Przyk≈Çady poprawnych komend
"python3 app.py --port 8080"
"java -Xmx512m -jar app.jar > app.log 2>&1"
"node server.js | tee /tmp/node.log"
```

#### `log_file`
≈öcie≈ºka do pliku, w kt√≥rym proces zapisuje logi. Monitor:
- Tworzy plik je≈õli nie istnieje
- Tworzy katalogi nadrzƒôdne je≈õli potrzeba
- Monitoruje zmiany rozmiaru i czasu modyfikacji

#### `timeout`
Czas w sekundach, po kt√≥rym proces zostanie zrestartowany je≈õli nie pojawiƒÖ siƒô nowe logi:
- **Kr√≥tkie (10-30s)** - dla szybkich aplikacji web
- **≈örednie (60-120s)** - dla standardowych aplikacji
- **D≈Çugie (300s+)** - dla proces√≥w batch/backup

#### `interval`
Czƒôstotliwo≈õƒá sprawdzania stanu procesu:
- **Czƒôste (1-5s)** - dla krytycznych aplikacji
- **Standardowe (5-15s)** - dla wiƒôkszo≈õci przypadk√≥w
- **Rzadkie (30s+)** - dla proces√≥w o niskim priorytecie

## Algorytm monitorowania

### 1. Inicjalizacja
```
Monitor tworzy kontekst i konfiguruje parametry
‚Üì
Waliduje ≈õcie≈ºki i tworzy katalogi dla log√≥w
‚Üì
Uruchamia pierwszy proces
‚Üì
Zapisuje poczƒÖtkowy stan pliku log√≥w
```

### 2. G≈Ç√≥wna pƒôtla monitorowania
```
Timer (co `interval` sekund)
‚Üì
Sprawd≈∫ czy proces ≈ºyje
‚îú‚îÄ NIE ‚Üí Restart procesu
‚îî‚îÄ TAK ‚Üí Sprawd≈∫ aktywno≈õƒá log√≥w
           ‚îú‚îÄ Nowe logi ‚Üí Kontynuuj
           ‚îú‚îÄ Brak zmian < timeout ‚Üí Kontynuuj
           ‚îî‚îÄ Brak zmian ‚â• timeout ‚Üí Restart procesu
```

### 3. Wykrywanie aktywno≈õci log√≥w
Monitor sprawdza:
1. **Rozmiar pliku** - czy plik ur√≥s≈Ç (nowe wpisy)
2. **Czas modyfikacji** - czy plik zosta≈Ç zmieniony
3. **Czas od ostatniej zmiany** - czy przekroczono timeout

```go
// Pseudokod logiki
if fileSize > lastSize {
    // Nowe logi - aktualizuj stan
    return aktywny
} else if modTime > lastModTime {
    // Plik przepisany - aktualizuj stan  
    return aktywny
} else if time.Since(lastChange) > timeout {
    // Timeout - restart potrzebny
    return nieaktywny
}
```

## ZarzƒÖdzanie procesami

### Uruchamianie procesu
```go
// Proces uruchamiany przez shell z kontekstem
cmd := exec.CommandContext(ctx, "sh", "-c", command)
err := cmd.Start()
```

### Zatrzymywanie procesu
1. **SIGTERM** - grzeczne zamkniƒôcie (5s timeout)
2. **SIGKILL** - wymuszone zamkniƒôcie (2s timeout)
3. **Cleanup** - zwolnienie zasob√≥w

```bash
# Sekwencja sygna≈Ç√≥w
SIGTERM ‚Üí czekaj 5s ‚Üí SIGKILL ‚Üí czekaj 2s ‚Üí cleanup
```

### Sprawdzanie stanu
```go
// Test czy proces ≈ºyje (sygna≈Ç 0)
err := process.Signal(syscall.Signal(0))
if err != nil {
    // Proces nie istnieje
}
```

## Obs≈Çuga b≈Çƒôd√≥w

### B≈Çƒôdy krytyczne (zako≈Ñczenie)
- B≈ÇƒÖd walidacji ≈õcie≈ºek
- Brak uprawnie≈Ñ do utworzenia plik√≥w
- Nieprawid≈Çowa sk≈Çadnia YAML

### B≈Çƒôdy odzyskiwalne (kontynuacja)
- Przej≈õciowe problemy z plikami
- B≈Çƒôdy uruchamiania procesu
- Problemy z sygna≈Çami

### Przyk≈Çadowy log b≈Çƒôd√≥w
```
2024-01-15 14:30:15 ERROR: Nie mo≈ºna odczytaƒá pliku log√≥w: permission denied
2024-01-15 14:30:16 INFO:  Ponawiam sprawdzenie za 5 sekund...
2024-01-15 14:30:20 INFO:  B≈ÇƒÖd restartu: exit status 1
2024-01-15 14:30:25 INFO:  Proces zrestartowany pomy≈õlnie
```

## Integracja z systemem

### Systemd Service
```ini
# /etc/systemd/system/monitor.service
[Unit]
Description=Process Monitor
After=network.target

[Service]
Type=simple
User=monitor
WorkingDirectory=/opt/monitor
ExecStart=/opt/monitor/monitor_mutex --config /etc/monitor/config.yaml
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

### Logrotate
```bash
# /etc/logrotate.d/monitor
/var/log/monitor/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    postrotate
        systemctl reload monitor.service
    endscript
}
```

### Docker
```dockerfile
FROM golang:1.21-alpine AS builder
WORKDIR /app
COPY monitor_mutex.go .
RUN go mod init monitor && \
    go get gopkg.in/yaml.v2 && \
    go build -o monitor monitor_mutex.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /app/monitor .
COPY config.yaml .
CMD ["./monitor", "--config", "config.yaml"]
```

## Monitorowanie i metryki

### Logi systemowe
Monitor wypisuje szczeg√≥≈Çowe informacje o:
- Uruchamianiu/zatrzymywaniu proces√≥w
- Stanie plik√≥w log√≥w
- Czasach restart√≥w
- B≈Çƒôdach i ostrze≈ºeniach

### Przyk≈Çadowy output
```
=== Monitor Proces√≥w ===
Plik log√≥w: /tmp/app.log
Timeout: 1m0s
Interwa≈Ç sprawdzania: 5s
--------------------------------------------------
Uruchamianie: python3 app.py
Proces uruchomiony z PID: 12345
PoczƒÖtkowy stan log√≥w: rozmiar 0 bajt√≥w
Nowe logi: rozmiar 0 -> 156 bajt√≥w (+156)
Nowe logi: rozmiar 156 -> 312 bajt√≥w (+156)
Oczekiwanie na zmiany w logach... (30s/1m0s)
TIMEOUT! Brak zmian w logach przez 1m5s (limit: 1m0s)
Restartowanie procesu - pow√≥d: brak aktywno≈õci w logach
Zatrzymywanie procesu PID: 12345
Proces zako≈Ñczony poprawnie
Uruchamianie: python3 app.py
Proces uruchomiony z PID: 12350
Proces zrestartowany pomy≈õlnie
```

### Metryki do monitorowania
- Liczba restart√≥w na godzinƒô
- ≈öredni czas dzia≈Çania procesu
- Czƒôstotliwo≈õƒá b≈Çƒôd√≥w
- Rozmiar plik√≥w log√≥w

## RozwiƒÖzywanie problem√≥w

### Problem: Process nie startuje
```bash
# Sprawd≈∫ czy komenda jest poprawna
sh -c "python3 app.py"

# Sprawd≈∫ uprawnienia
ls -la /path/to/app.py

# Sprawd≈∫ zale≈ºno≈õci
which python3
```

### Problem: Czƒôste restarty
```yaml
# Zwiƒôksz timeout
timeout: 300  # z 60 na 300 sekund

# Zmniejsz interwa≈Ç (szybsze wykrywanie aktywno≈õci)
interval: 2   # z 5 na 2 sekundy
```

### Problem: Logi nie sƒÖ wykrywane
```bash
# Sprawd≈∫ czy aplikacja faktycznie pisze do pliku
tail -f /tmp/app.log

# Sprawd≈∫ uprawnienia do pliku
ls -la /tmp/app.log

# Sprawd≈∫ czy plik jest zapisywany
watch "ls -la /tmp/app.log"
```

### Problem: Monitor siƒô zawiesza
```bash
# Sprawd≈∫ procesy
ps aux | grep monitor

# Sprawd≈∫ sygna≈Çy
kill -USR1 <monitor_pid>  # debug info
kill -TERM <monitor_pid>  # graceful shutdown
```

## Zaawansowane przypadki u≈ºycia

### 1. Monitoring klastra aplikacji
```yaml
processes:
  - name: "web-1"
    command: "python3 app.py --port 8001"
    log_file: "/var/log/web-1.log"
    timeout: 30
    interval: 5
    
  - name: "web-2" 
    command: "python3 app.py --port 8002"
    log_file: "/var/log/web-2.log"
    timeout: 30
    interval: 5
    
  - name: "worker"
    command: "python3 worker.py"
    log_file: "/var/log/worker.log"
    timeout: 120
    interval: 10
```

### 2. Monitoring z preprocessing
```yaml
processes:
  - name: "data-processor"
    command: "python3 processor.py | tee /tmp/processor.log"
    log_file: "/tmp/processor.log"
    timeout: 600  # 10 minut na batch
    interval: 30
```

### 3. Monitoring z cleanup
```yaml
processes:
  - name: "cleaner"
    command: "bash -c 'while true; do cleanup.sh >> /tmp/clean.log 2>&1; sleep 3600; done'"
    log_file: "/tmp/clean.log" 
    timeout: 7200  # 2 godziny
    interval: 60
```

## Por√≥wnanie z innymi rozwiƒÖzaniami

### vs Systemd
| Cecha | Monitor Mutex | Systemd |
|-------|---------------|---------|
| Restart na brak log√≥w | ‚úÖ | ‚ùå |
| Konfiguracja YAML | ‚úÖ | ‚ùå |
| Lekki footprint | ‚úÖ | ‚ùå |
| Integracja systemowa | ‚ùå | ‚úÖ |

### vs Supervisor
| Cecha | Monitor Mutex | Supervisor |
|-------|---------------|------------|
| Monitoring log√≥w | ‚úÖ | ‚ùå |
| Go dependency | ‚úÖ | ‚ùå |
| Python dependency | ‚ùå | ‚úÖ |
| Web interface | ‚ùå | ‚úÖ |

### vs Docker healthcheck
| Cecha | Monitor Mutex | Docker |
|-------|---------------|---------|
| Log-based restart | ‚úÖ | ‚ùå |
| Native processes | ‚úÖ | ‚ùå |
| Container overhead | ‚ùå | ‚úÖ |
| Orchestration | ‚ùå | ‚úÖ |

## Wymagania systemowe

### Minimalne wymagania
- **OS**: Linux, macOS, Windows (ograniczone)
- **RAM**: 10MB
- **CPU**: Dowolny (bardzo niskie u≈ºycie)
- **Go**: 1.19+ (do kompilacji)

### Zalecane narzƒôdzia
- `ps` - informacje o procesach
- `kill` - wysy≈Çanie sygna≈Ç√≥w
- `tail` - debugowanie log√≥w

### Zale≈ºno≈õci Go
```bash
go mod init monitor
go get gopkg.in/yaml.v2
```

## Rozw√≥j i contribucje

### Planowane funkcje
- [ ] Metryki Prometheus
- [ ] Web dashboard
- [ ] Slack/Discord notyfikacje
- [ ] Rolling restarts
- [ ] Health checks HTTP
- [ ] Log parsing rules

### Struktura kodu
```
monitor_mutex.go
‚îú‚îÄ‚îÄ Types (Config, Monitor, ProcessConfig)
‚îú‚îÄ‚îÄ Core Logic (Monitor.Run, checkLogs, startProcess)
‚îú‚îÄ‚îÄ Process Management (killProcess, isProcessRunning)
‚îú‚îÄ‚îÄ Configuration (loadConfig, validation)
‚îî‚îÄ‚îÄ CLI Interface (main, printUsage)
```

### Testowanie
```bash
# Unit testy
go test -v

# Integration testy
./test_scenarios.sh

# Load test
for i in {1..10}; do ./monitor_mutex "echo test" "/tmp/test$i.log" & done
```
